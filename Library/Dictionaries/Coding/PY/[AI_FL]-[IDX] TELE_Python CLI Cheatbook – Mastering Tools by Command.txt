
---

# üì° Telegram Bot as a Remote PC Assistant

> *"How to Turn a Free Telegram Bot into Your Personal Remote-Controlled Server Butler."*

---

## üìö Contents

1. **Introduction**
2. **System Requirements**
3. **Bot Setup & Access**
4. **Bot-to-PC Communication (How It Works)**
5. **Script Execution Examples**
6. **Security & Fail-safes**
7. **What‚Äôs Next?**

---

## 1. üì¢ Introduction

Telegram Bots aren‚Äôt just chat toys.
With a few tweaks, you can *command your entire PC* from your phone with Telegram commands: run scripts, check status, or even reboot it.

This method is perfect if:

* You **leave your PC on** or use Wake-on-LAN.
* You **forget** to leave remote access running.
* You want **simple commands** to control **scripts or apps remotely**.

No TeamViewer lag. No RustDesk limitations. No UI faffing. Just pure control.

---

## 2. üß∞ System Requirements

| Item               | Details                                   |
| ------------------ | ----------------------------------------- |
| Telegram Account   | On your Android or iOS phone              |
| Python (3.8+)      | Installed on the PC                       |
| Telegram Bot Token | From [@BotFather](https://t.me/botfather) |
| Ngrok (optional)   | If your PC is not public-facing           |
| Script(s) to run   | `.bat`, `.ps1`, `.py`, etc.               |

---

## 3. ü§ñ Bot Setup & Access

### üõ†Ô∏è Step-by-Step Bot Creation:

1. Go to Telegram ‚Üí Search: `@BotFather`
2. Start a chat and type `/newbot`
3. Follow prompts: Give it a name and a username (`something_bot`)
4. **You‚Äôll be given an API token. Save this.**

Example Token:

```
123456789:ABCdefGHIJKLmnoPQRStuvWXYZ9_abCdEfGh
```

### ‚úÖ Optional but useful:

* Set a **profile picture**
* Add a **description**
* Use `/setcommands` to define helpful command hints

---

## 4. üîÅ Bot-to-PC Communication

### üì¶ Architecture Overview:

```plaintext
You (phone) ‚îÄ‚ñ∫ Telegram bot ‚îÄ‚ñ∫ Your PC (listening script) ‚îÄ‚ñ∫ Action!
```

* Your PC runs a Python script that listens for messages sent to your bot.
* When it sees a certain command (`/startchrome`, `/runscan`), it **runs a script or command** on your PC.

Simple. Smart. Yours.

---

## 5. üß™ Script Execution Examples

```python
# basic_bot.py
from telegram.ext import Updater, CommandHandler
import os

TOKEN = "YOUR_BOT_TOKEN_HERE"

def start(update, context):
    update.message.reply_text("Bot is alive. Type /run to trigger script.")

def run_script(update, context):
    os.system("start notepad.exe")  # Change this to any script

updater = Updater(TOKEN)
dp = updater.dispatcher
dp.add_handler(CommandHandler("start", start))
dp.add_handler(CommandHandler("run", run_script))

updater.start_polling()
updater.idle()
```

üß† Replace `"start notepad.exe"` with any of your own scripts (`shutdown`, `python3 myscript.py`, etc.)

---

## 6. üõ°Ô∏è Quick Security Tips:

* üîê **Never share your token**
* üìç Use `chat_id` filters to **allow only your account** to trigger actions.
* ‚è±Ô∏è Use a time lock (`only between 7AM-10PM`) to prevent abuse
* üîÑ Log everything to file: who asked for what, and when

---

## 7. üöÄ What‚Äôs Next?

You‚Äôve now got the bones of a bot PC assistant.
Up next we go hard on setting up security.
Once thats out of the way it's time to have some fun by **hooking it into ChatGPT and make it think.**
After that ‚Äî real-time home automation, smart responses, logging, auto screenshots ‚Äî the works.

---

# üõ°Ô∏è Chapter 2: Security

> *Protecting Your PC, Bot, and Data from the Wild Internet and Dumber Hackers*

---

## üìö Contents

1. **Why Security Matters**
2. **Limiting Access with `chat_id`**
3. **Rate-Limiting & Command Cooldowns**
4. **Safe Script Execution Practices**
5. **Using Secrets Safely**
6. **Logging & Audit Trails**
7. **Sample Secure Bot Code**
8. **Next Steps**

---

## 1. üß† Why Security Matters

Telegram bots are incredibly powerful ‚Äî especially when controlling a personal machine.

A poorly secured bot could:

* Be used by strangers to run *any* command.
* Leak information about your system.
* Be discovered and brute-forced if not properly filtered.

**Security is not optional. It‚Äôs fundamental.**

---

## 2. üîí Limiting Access with `chat_id`

Telegram bots receive messages from **any user** unless filtered.

To fix this, lock your bot to your own `chat_id`.

### ‚ú≥Ô∏è How to Find Your `chat_id`:

Run this once in your bot:

```python
def get_chat_id(update, context):
    update.message.reply_text(f"Your Chat ID is: {update.message.chat_id}")
```

Use this in your code:

```python
ALLOWED_USERS = [123456789]  # Replace with your actual chat ID

def restricted(func):
    def wrapper(update, context):
        if update.effective_user.id not in ALLOWED_USERS:
            update.message.reply_text("Unauthorized.")
            return
        return func(update, context)
    return wrapper
```

Apply it to commands:

```python
@restricted
def run_script(update, context):
    os.system("start notepad.exe")
```

---

## 3. ‚è≥ Rate-Limiting & Cooldowns

Stop your bot being spammed or used rapidly:

```python
from datetime import datetime, timedelta

last_used = {}

def cooldown(seconds):
    def decorator(func):
        def wrapper(update, context):
            user = update.effective_user.id
            now = datetime.now()
            if user in last_used:
                elapsed = (now - last_used[user]).total_seconds()
                if elapsed < seconds:
                    update.message.reply_text(f"Wait {int(seconds - elapsed)}s.")
                    return
            last_used[user] = now
            return func(update, context)
        return wrapper
    return decorator
```

Usage:

```python
@restricted
@cooldown(30)  # 30 second cooldown
def run_script(update, context):
    os.system("start notepad.exe")
```

---

## 4. üßº Safe Script Execution Practices

Running raw commands is **dangerous**.

### ‚úÖ Tips:

* Avoid `eval()` or dynamic execution from user input.
* Store all commands in a *whitelist* dictionary.

```python
SCRIPTS = {
    "note": "start notepad.exe",
    "browser": "start chrome.exe",
    "shutdown": "shutdown /s /t 5"
}

def run_whitelisted(update, context):
    arg = context.args[0] if context.args else ""
    if arg in SCRIPTS:
        os.system(SCRIPTS[arg])
        update.message.reply_text(f"Running: {arg}")
    else:
        update.message.reply_text("Unknown or blocked command.")
```

---

## 5. üóùÔ∏è Using Secrets Safely

Avoid hardcoding tokens in public/shared files.

Use `.env` or external secrets files:

```python
# .env file
BOT_TOKEN=123456:ABC-YourRealTokenHere
```

Load it:

```python
from dotenv import load_dotenv
import os
load_dotenv()
TOKEN = os.getenv("BOT_TOKEN")
```

Never upload `.env` files to GitHub. Add it to `.gitignore`.

---

## 6. üßæ Logging & Audit Trails

Log every command for debugging, accountability, and safety.

```python
import logging

logging.basicConfig(
    filename="bot_activity.log",
    level=logging.INFO,
    format='%(asctime)s - %(user)s - %(command)s'
)

def log_command(user, command):
    logging.info("", extra={"user": user, "command": command})
```

Call inside your function:

```python
log_command(update.effective_user.username, "run_script")
```

Bonus: Store logs in `.csv` for easy filtering in Excel.

---

## 7. üìÑ Sample: Secure Bot Skeleton

```python
from telegram.ext import Updater, CommandHandler
import os
from datetime import datetime, timedelta

ALLOWED_USERS = [123456789]
last_used = {}

def restricted(func):
    def wrapper(update, context):
        if update.effective_user.id not in ALLOWED_USERS:
            update.message.reply_text("Unauthorized.")
            return
        return func(update, context)
    return wrapper

def cooldown(seconds):
    def decorator(func):
        def wrapper(update, context):
            user = update.effective_user.id
            now = datetime.now()
            if user in last_used:
                elapsed = (now - last_used[user]).total_seconds()
                if elapsed < seconds:
                    update.message.reply_text(f"Cooldown: {int(seconds - elapsed)}s.")
                    return
            last_used[user] = now
            return func(update, context)
        return wrapper
    return decorator

SCRIPTS = {
    "note": "start notepad.exe",
    "browser": "start chrome.exe"
}

@restricted
@cooldown(10)
def run(update, context):
    cmd = context.args[0] if context.args else ""
    if cmd in SCRIPTS:
        os.system(SCRIPTS[cmd])
        update.message.reply_text(f"Executed {cmd}.")
    else:
        update.message.reply_text("Invalid or blocked.")

updater = Updater("YOUR_TOKEN")
updater.dispatcher.add_handler(CommandHandler("run", run))
updater.start_polling()
updater.idle()
```

---

## 8. üì¶ Next Steps

In the next chapter:

* Advanced bot routing
* JSON command parsing
* Environment-specific triggers
* Multi-device handling
* Building a terminal-style chat interface

---

# üíª Chapter 3: Advanced Interaction & Commands

> *Transforming Your Bot from a Dumb Trigger Monkey to a Responsive Command Console*

---

## üìö Contents

1. **Beyond the Basics: Command Styles**
2. **Multi-Command Payloads**
3. **Handling Parameters with Flags**
4. **Inline Buttons & Interactive Responses**
5. **Building a Command Shell UI**
6. **Examples: Real World Bot Flows**
7. **Command Whitelist via JSON**
8. **Command Categories & Help Menus**
9. **Next Steps**

---

## 1. üöÄ Beyond the Basics: Command Styles

Telegram allows for multiple ways to send a command:

| Type        | Example              | Notes                                   |
| ----------- | -------------------- | --------------------------------------- |
| Classic     | `/run notepad`       | Default. Fast. Plaintext.               |
| Button      | Inline "Run Notepad" | Cleaner UX. Use `InlineKeyboardButton`. |
| Menu-Driven | Select from list     | Good for mobile. Makes mistakes rare.   |

You are not limited to just `/commands`. You can create **custom syntaxes**:

```python
# Example: Use ! as a trigger
if text.startswith("!run"):
    ...
```

---

## 2. üßæ Multi-Command Payloads

Enable power users to send multiple commands in one go:

**Message:**

```
/run note
/run browser
```

**Bot:**

```python
def multi_command(update, context):
    for line in update.message.text.splitlines():
        if line.startswith("/run"):
            parts = line.split()
            if len(parts) > 1 and parts[1] in SCRIPTS:
                os.system(SCRIPTS[parts[1]])
```

> üîê Restrict this to trusted users only. Mass command abuse is real.

---

## 3. üéõ Handling Parameters with Flags

Turn your bot into a CLI-style interpreter:

**Command:**

```
/upload -f filename.txt -d "C:\Docs" --overwrite
```

Parse it:

```python
import shlex

def parse_command(text):
    return shlex.split(text)
```

Now support:

* `-f` or `--file`
* `-d` or `--destination`
* `--overwrite`

Use it with argparse or manual parsing logic.

---

## 4. üñ≤ Inline Buttons & Interactive Responses

Better than typing ‚Äî clickable bot UI:

```python
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

def show_options(update, context):
    keyboard = [
        [InlineKeyboardButton("Run Notepad", callback_data='run_note')],
        [InlineKeyboardButton("Shutdown", callback_data='run_shutdown')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text("Choose an action:", reply_markup=reply_markup)
```

Handle it:

```python
def button_handler(update, context):
    query = update.callback_query
    query.answer()
    if query.data == 'run_note':
        os.system("start notepad.exe")
```

---

## 5. üß† Building a Command Shell UI

Let‚Äôs simulate a terminal:

* User types: `/cmd dir C:\Temp`
* Bot replies with:

  ```
  üìÇ Listing for C:\Temp:n
  - file1.txt
  - file2.exe
  ```

**Command Handler:**

```python
@restricted
def cmd(update, context):
    cmd = ' '.join(context.args)
    output = os.popen(cmd).read(3000)
    update.message.reply_text(f"üìü Output:\n{output}")
```

> üîê Never allow this without a `@restricted` decorator. It is **raw access** to the system shell.

---

## 6. üîÑ Examples: Real Bot Flows

| Flow         | Trigger               | Result                              |
| ------------ | --------------------- | ----------------------------------- |
| Light Toggle | `/toggle light`       | Sends command to smart plug         |
| Safe Start   | `/safe start`         | Launches system with checks         |
| Screenshot   | `/shot`               | Sends back desktop screenshot       |
| App Monitor  | `/check process_name` | Returns status: running or not      |
| Backup       | `/backup now`         | Executes system-level backup script |

All can be abstracted behind a command framework.

---

## 7. üìÅ Command Whitelist via JSON

Keep a JSON file of allowed commands:

```json
{
  "scripts": {
    "note": "start notepad.exe",
    "calc": "start calc.exe"
  }
}
```

Load it:

```python
import json
with open("scripts.json") as f:
    SCRIPTS = json.load(f)["scripts"]
```

Clean, editable, safer.

---

## 8. üßæ Command Categories & Help Menus

Group and organize:

```python
COMMAND_GROUPS = {
    "Apps": ["note", "calc", "paint"],
    "System": ["shutdown", "restart"],
    "Tools": ["backup", "scan"]
}
```

Auto-generate a help menu:

```python
def help(update, context):
    text = "üìñ Available Commands:\n"
    for cat, cmds in COMMAND_GROUPS.items():
        text += f"\nüîπ *{cat}*\n" + "\n".join(f"/run {c}" for c in cmds)
    update.message.reply_text(text, parse_mode="Markdown")
```

---

## 9. ‚û°Ô∏è Next Steps

Next chapter will cover **Chapter 4: Triggers, Auto-Actions, and Background Watchers**, including:

* Message-based triggers
* Status monitoring
* System events
* Scheduled actions





